<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2020年度总结</title>
      <link href="/2020/12/31/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-2020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2020/12/31/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-2020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>&#8195;&#8195;进入游戏行业已经有几年了，不过前几年的时间大都是在用cocos，工作作息基本为996，个人的视野也就颇为局限。今年年初终于正式开始使用unity，996的作息也变少了很多，有了不少业余时间学习后，才猛然发现自己早就被行业前沿远远甩开。图形学、C#、C++、Unity、Unreal、DCC工具等，都是一个游戏客户端所需要去了解去学习的东西。</p><p>&#8195;&#8195;在今年的学习过程中，经常会有要学习的东西太多反而不知从何下手的茫然。不过在这茫然中总算在各方面都多少有了些了解。</p><ul><li>图形学、C++：<ul><li>编写了个简单的软件渲染器，对渲染的基本流程有了较清晰的理解。</li><li>观看和阅读了诸多教程视频和文章，对图形学内的许多概念有了了解。</li></ul></li><li>Unity、C#、Lua：<ul><li>阅读并实验了诸多相关书籍（如《Unity3D游戏开发》）和博客（如Catlikecoding系列）。</li><li>阅读《Lua源码欣赏》和Lua源码，了解了Lua中String、Table的实现。</li><li>阅读《C#本质论》和《CLR via C#》。</li><li>参考了一些开源框架，自己写了个简单的游戏框架，进一步熟悉了C#和Unity。</li><li>学习URP，在URP尝试实现了一些简单后处理、水体渲染(主要参照Boat Attack)、刀剑划痕等。</li></ul></li><li>其他：<ul><li>公司项目内有负责战斗系统、技能系统的搭建和编写，对于这方面多了些经验。</li></ul></li></ul><p>&#8195;&#8195;经过这一年的学习，对于Unity算是比较熟悉了，但对于图形学应该还只能算是初步入门。明年需要进一步学习图形学，并且更重要的是需要学习如何利用图形学做出好的表现，这需要美术知识的学习和个人审美的提升。</p><ul><li>图形学、C++：<ul><li>编写个人渲染引擎，图形api暂定vulkan，界面用imgui。</li></ul></li><li>Unity、C#、Lua：<ul><li>已报Kerry的TA课程，学习时长20周。</li></ul></li></ul><p>&#8195;&#8195;对于明年的学习，并没有进行特别细致的计划，只列了主要的两项：个人渲染引擎和TA入门。个人渲染引擎是为了进一步地深入学习图形学及锻炼C++水平。TA入门的目标并不代表之后要转方向做TA，而是为了做出优秀的渲染表现，需要这方面的学习。</p><p>&#8195;&#8195;总的来说，要学的东西还很多，这条路还很长。我不需要因一时的落后而焦虑，重要地是走稳接下来每一步。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Unity URP】水体渲染</title>
      <link href="/2020/11/22/Unity-URP-%E6%B0%B4%E4%BD%93%E6%B8%B2%E6%9F%93/"/>
      <url>/2020/11/22/Unity-URP-%E6%B0%B4%E4%BD%93%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<p>unity版本：2019.4.12f<br>urp版本：7.5.1</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#8195;&#8195;Unity URP有一个很好的官方示例项目<a href="https://github.com/Verasl/BoatAttack" target="_blank" rel="noopener">Boat Attack</a>，我最近参考该项目实现了下水体渲染，所以水篇文章记录下。</p><h2 id="波形"><a href="#波形" class="headerlink" title="波形"></a>波形</h2><p>&#8195;&#8195;我是直接用了标准3d模型Plane作为水面，不过有用上曲面细分，关于曲面细分我有另写过文章(<a href="https://wyk223344.github.io/2020/11/20/Unity曲面细分/">链接</a>)。<br><img src="https://img-blog.csdnimg.cn/2020112320462450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5azIyMzM0NA==,size_16,color_FFFFFF,t_70#pic_center" alt="Sine vs. Gerstner wave"><br>&#8195;&#8195;波形的实现则使用了Gerstner波来进行叠加。如上图所示，Gerstner相较于正弦波波峰更尖锐而波谷更宽阔。关于Gerstner的相关文章很多，比如这<a href="https://catlikecoding.com/unity/tutorials/flow/waves/" target="_blank" rel="noopener">一篇</a>，这里就不详细展开了。</p><h2 id="散射和吸收"><a href="#散射和吸收" class="headerlink" title="散射和吸收"></a>散射和吸收</h2><p><img src="https://img-blog.csdnimg.cn/20201123211107293.png#pic_center" alt="在这里插入图片描述"></p><p>&#8195;&#8195;对于水体的着色，则是生成两张Ramp图，表示不同深度下的散射(Scattering)和吸收(Absorption)的颜色。这里的深度指的是深度图在水面下的部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">float UnderwaterDepthDistance(float2 screenPos, float3 positionVS)</span><br><span class="line">&#123;</span><br><span class="line">    float depthTex &#x3D; SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, sampler_ScreenTextures_linear_clamp, screenPos);</span><br><span class="line">    float depthCamera2End &#x3D; LinearEyeDepth(depthTex, _ZBufferParams);</span><br><span class="line">    return depthCamera2End + positionVS.z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half3 Scattering(half depth)</span><br><span class="line">&#123;</span><br><span class="line">return SAMPLE_TEXTURE2D(_WaterRampMap, sampler_WaterRampMap, half2(depth, 0.375h)).rgb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half3 Absorption(half depth)</span><br><span class="line">&#123;</span><br><span class="line">return SAMPLE_TEXTURE2D(_WaterRampMap, sampler_WaterRampMap, half2(depth, 0.0h)).rgb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;获取到散射和吸收的颜色后，就可以渲染出有不错的水体着色效果了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float depthDistance &#x3D; UnderwaterDepthDistance(screenPos, positionVS);</span><br><span class="line">half3 opaueTex &#x3D; SAMPLE_TEXTURE2D_LOD(_CameraOpaqueTexture, sampler_CameraOpaqueTexture_linear_clamp, distortion, depthDistance * 0.25).rgb;</span><br><span class="line">float3 diffuse &#x3D; opaueTex * Absorption((depthDistance) * depthMulti) + Scattering(depthDistance * depthMulti);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201123212453603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5azIyMzM0NA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="浮沫"><a href="#浮沫" class="headerlink" title="浮沫"></a>浮沫</h2><p>&#8195;&#8195;水在靠岸边的地方一般会有浮沫(Foam)。Boat Attack里，是专门用了一个摄像机自上而下的来拍摄水底的深度。不过因为浮沫本身也要随波浪不停变化，所以我仍采用的是前面得到的depthDistance来进行深度判断，也暂未发现这样得到的浮沫有什么问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">float2 uv2 &#x3D; positionWS.xz * 0.1 + _Time.y * 0.05;</span><br><span class="line">half3 foamMap &#x3D; SAMPLE_TEXTURE2D(_FoamMap, sampler_FoamMap, uv2).rgb;</span><br><span class="line">half edgeFoam &#x3D; saturate(1 - depthDistance * 0.5 - 0.25);</span><br><span class="line">half foamBlendMask &#x3D; max(0, edgeFoam);</span><br><span class="line">half3 foamBlend &#x3D; SAMPLE_TEXTURE2D(_FoamRamp, sampler_FoamRamp, half2(foamBlendMask, 0.66)).rgb;</span><br><span class="line">half foamMask &#x3D; saturate(length(foamMap * foamBlend) * 1.5 - 0.1 + saturate(1 - depthDistance * 4) * 0.5);</span><br><span class="line">half3 foam &#x3D; foamMask.xxx * (mainLight.shadowAttenuation * mainLight.color);</span><br><span class="line">diffuse &#x3D; lerp(diffuse, foam, foamMask);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201123214130801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5azIyMzM0NA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="焦散"><a href="#焦散" class="headerlink" title="焦散"></a>焦散</h2><p>&#8195;&#8195;焦散是布于水底的，所以需要根据深度图获取水底坐标，然后用水底的坐标作为uv去采样焦散图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">float3 ReconstructWorldPos(half2 screenPos)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; World Pos reconstriction</span><br><span class="line">    float depthTex &#x3D; SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, sampler_ScreenTextures_linear_clamp, screenPos);</span><br><span class="line">    float4 raw &#x3D; mul(UNITY_MATRIX_I_VP, float4(screenPos * 2 - 1, depthTex, 1));</span><br><span class="line">    float3 worldPos &#x3D; raw.rgb &#x2F; raw.a;</span><br><span class="line">    return worldPos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float3 Caustics(half3 depthPositionWS)</span><br><span class="line">&#123;</span><br><span class="line">    float2 uv &#x3D; depthPositionWS.xz * 0.1 + float2(_Time.y, _Time.x) * 0.1;</span><br><span class="line">    return SAMPLE_TEXTURE2D(_CausticsMap, sampler_CausticsMap, uv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;因为焦散布于水底，所以应该调整下diffuse的获取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float3 diffuse &#x3D; (opaueTex + caustics) * Absorption((depthDistance) * depthMulti) + Scattering(depthDistance * depthMulti);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201123215106954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5azIyMzM0NA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="高光"><a href="#高光" class="headerlink" title="高光"></a>高光</h2><p>&#8195;&#8195;Urp本身就有自带的高光实现，就在ShaderLibrary/Lighting.hlsl内，采用的是简版CookTorrance模型的BRDF。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BRDFData brdfData;</span><br><span class="line">InitializeBRDFData(half3(0, 0, 0), 0, half3(1, 1, 1), 0.9, 1, brdfData);</span><br><span class="line">half3 spec &#x3D; DirectBDRF(brdfData, normalWS, mainLight.direction, viewDirWS) * mainLight.shadowAttenuation * mainLight.color;</span><br><span class="line">return float4(diffuse + spec, 1);</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;我们还可以用额外的噪声图来丰富法线的细节，使得更有波光粼粼的感觉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">half2 detailBump1 &#x3D; SAMPLE_TEXTURE2D(_SurfaceMap, sampler_SurfaceMap, uv2).xy * 2 - 1;</span><br><span class="line">half2 detailBump2 &#x3D; SAMPLE_TEXTURE2D(_SurfaceMap, sampler_SurfaceMap, uv1).xy * 2 - 1;</span><br><span class="line">half2 detailBump &#x3D; (detailBump1 + detailBump2 * 0.5) * saturate(depthDistance * 0.25 + 0.25);</span><br><span class="line">normalWS +&#x3D; half3(detailBump.x, 0, detailBump.y) * _BumpScale;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201123220557799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5azIyMzM0NA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/127116312" target="_blank" rel="noopener">Boat Attack 项目海水技术解析</a></li><li><a href="https://zhuanlan.zhihu.com/p/95917609" target="_blank" rel="noopener">真实感水体渲染技术总结</a></li><li><a href="https://github.com/Verasl/BoatAttack" target="_blank" rel="noopener">https://github.com/Verasl/BoatAttack</a></li><li><a href="https://catlikecoding.com/unity/tutorials/flow/waves/" target="_blank" rel="noopener">https://catlikecoding.com/unity/tutorials/flow/waves/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Unity URP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Unity URP】曲面细分</title>
      <link href="/2020/11/20/Unity%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86/"/>
      <url>/2020/11/20/Unity%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>unity版本：2019.4.12f<br>urp版本：.7.5.1</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://img-blog.csdnimg.cn/20201120215751493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5azIyMzM0NA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>&#8195;&#8195;曲面细分是渲染管线的可选阶段，作用是可以将三角形分的更精细。如上图所示，曲面细分包含Hull Program、Tessellation和Domain Program这三步，处于顶点着色器之后，几何着色器之前，其中的Hull Program和Domain Program可编程。</p><h2 id="Hull-Program"><a href="#Hull-Program" class="headerlink" title="Hull Program"></a>Hull Program</h2><p>&#8195;&#8195;Hull Program负责决定如何细分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[domain(&quot;tri&quot;)]&#x2F;&#x2F; 表示适用于三角形，还有quad(四边形)</span><br><span class="line">[outputcontrolpoints(3)]&#x2F;&#x2F; 输出的控制点数量</span><br><span class="line">[outputtopology(&quot;triangle_cw&quot;)]&#x2F;&#x2F; 输出拓扑结构为顺时针三角形，还有triangle_ccw(逆时针三角形)、line(线段)</span><br><span class="line">[partitioning(&quot;fractional_odd&quot;)] &#x2F;&#x2F; 分数分割模式，还有integer(整数模式)</span><br><span class="line">[patchconstantfunc(&quot;PatchConstantFunction&quot;)]&#x2F;&#x2F; 划分方法</span><br><span class="line">TessellationControlPoint Hull(</span><br><span class="line">InputPatch&lt;TessellationControlPoint, 3&gt; input,&#x2F;&#x2F; 输入的顶点数据格式和数量</span><br><span class="line">    uint id : SV_OutputControlPointID&#x2F;&#x2F; 索引id</span><br><span class="line">) &#123;</span><br><span class="line">   return input[id];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Patch-Constant-Functions"><a href="#Patch-Constant-Functions" class="headerlink" title="Patch Constant Functions"></a>Patch Constant Functions</h3><p>&#8195;&#8195;三角形的划分方法通过4个因子来控制划分效果。其中SV_TessFactor表示边缘划分因子，控制边缘的划分数量。SV_InsideTessFactor则表示内部划分因子，控制的是内部三角形的多寡。具体划分方式受分割模式影响(partitioning)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct TessellationFactors</span><br><span class="line">&#123;</span><br><span class="line">float tessFactor[3]    : SV_TessFactor;</span><br><span class="line">float insideTessFactor : SV_InsideTessFactor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Domain-Program"><a href="#Domain-Program" class="headerlink" title="Domain Program"></a>Domain Program</h2><p>&#8195;&#8195;Hull 决定了如何分面，那么Domain则决定了顶点的属性。在前面的进行细分时，实际还并没有真正生成点，只是决定了点在三角形内的重心坐标barycentricCoordinates。所以在Domain阶段，则需要自己根据重心坐标来真正的生成点数据。对于那些之前在顶点着色器内做的操作则可以移到这里进行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[domain(&quot;tri&quot;)]</span><br><span class="line">GeometryPoint Domain(</span><br><span class="line">TessellationFactors factors,</span><br><span class="line">OutputPatch&lt;TessellationControlPoint, 3&gt; input,</span><br><span class="line">float3 barycentricCoordinates : SV_DomainLocation)</span><br><span class="line">&#123;</span><br><span class="line">GeometryPoint output;</span><br><span class="line">float fU &#x3D; barycentricCoordinates.x;</span><br><span class="line">float fV &#x3D; barycentricCoordinates.y;</span><br><span class="line">float fW &#x3D; barycentricCoordinates.z;</span><br><span class="line">float4 positionOS &#x3D; input[0].positionOS * fU + input[1].positionOS * fV + input[2].positionOS * fW;</span><br><span class="line">output.positionCS &#x3D; TransformObjectToHClip(positionOS.xyz);</span><br><span class="line">return output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="细分三角形"><a href="#细分三角形" class="headerlink" title="细分三角形"></a>细分三角形</h2><p>&#8195;&#8195;前面有提到，三角形的具体划分方式是通过在Patch Constant Functions里设置划分因子决定的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TessellationFactors PatchConstantFunction (InputPatch&lt;TessellationControlPoint, 3&gt; input)</span><br><span class="line">&#123;</span><br><span class="line">TessellationFactors output;</span><br><span class="line">output.tessFactor[0] &#x3D; 2;</span><br><span class="line">output.tessFactor[1] &#x3D; 2;</span><br><span class="line">output.tessFactor[2] &#x3D; 2;</span><br><span class="line">output.insideTessFactor &#x3D; 2;</span><br><span class="line">return output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&#8195;&#8195;当划分因子如上图设置时，划分结果为下图所示</p><p><img src="https://img-blog.csdnimg.cn/20201120225436289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5azIyMzM0NA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>&#8195;&#8195;那么划分因子具体设置何值为好呢？我们可以设立两个标准，一个是划分因子受边长决定，另一个是划分因子受边到摄像机的距离决定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">float TessellationEdgeFactor(float3 p0, float3 p1) </span><br><span class="line">&#123;</span><br><span class="line">float edgeLength &#x3D; distance(p0, p1);</span><br><span class="line">float3 edgeCenter &#x3D; (p0 + p1) * 0.5;</span><br><span class="line">float viewDistance &#x3D; distance(edgeCenter, _WorldSpaceCameraPos);</span><br><span class="line">return edgeLength * _ScreenParams.y &#x2F; (_TessellationEdgeLength * viewDistance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TessellationFactors PatchConstantFunction (InputPatch&lt;TessellationControlPoint, 3&gt; input)</span><br><span class="line">&#123;</span><br><span class="line">float3 p0 &#x3D; TransformObjectToWorld(input[0].positionOS.xyz);</span><br><span class="line">float3 p1 &#x3D; TransformObjectToWorld(input[1].positionOS.xyz);</span><br><span class="line">float3 p2 &#x3D; TransformObjectToWorld(input[2].positionOS.xyz);</span><br><span class="line">TessellationFactors output &#x3D; (TessellationFactors)0;</span><br><span class="line">output.tessFactor[0] &#x3D; TessellationEdgeFactor(p1, p2);</span><br><span class="line">output.tessFactor[1] &#x3D; TessellationEdgeFactor(p2, p0);</span><br><span class="line">output.tessFactor[2] &#x3D; TessellationEdgeFactor(p0, p1);</span><br><span class="line"> output.insideTessFactor &#x3D; (TessellationEdgeFactor(p1, p2) + </span><br><span class="line">TessellationEdgeFactor(p2, p0) + </span><br><span class="line">TessellationEdgeFactor(p0, p1)) * (1 &#x2F; 3.0);</span><br><span class="line">return output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201120230922278.png#pic_center" alt="在这里插入图片描述"><br>&#8195;&#8195;代码与划分效果如上图。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>1、<a href="https://catlikecoding.com/unity/tutorials/advanced-rendering/tessellation/" target="_blank" rel="noopener">https://catlikecoding.com/unity/tutorials/advanced-rendering/tessellation/</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity URP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua源码之表</title>
      <link href="/2020/08/08/Lua%E6%BA%90%E7%A0%81%E4%B9%8B%E8%A1%A8/"/>
      <url>/2020/08/08/Lua%E6%BA%90%E7%A0%81%E4%B9%8B%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>lua版本：5.3.5</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>&#8195;&#8195;table是lua唯一的数据结构，也是lua最明显的特色之一，使用者可以在table的基础上实现各种各样的数据结构。table即可以作为数组，又可以作为哈希表，而在实现上，源码里也是将table的内部存储分为了数组和哈希表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Tables</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> TKey &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    TValuefields;</span><br><span class="line">    <span class="keyword">int</span> next;  <span class="comment">/* for chaining (offset for next node) */</span></span><br><span class="line">  &#125; nk;</span><br><span class="line">  TValue tvk;</span><br><span class="line">&#125; TKey;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  TValue i_val;</span><br><span class="line">  TKey i_key;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  lu_byte flags;  <span class="comment">/* 1&lt;&lt;p means tagmethod(p) is not present */</span></span><br><span class="line">  lu_byte lsizenode;  <span class="comment">/* log2 of size of 'node' array */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> sizearray;  <span class="comment">/* size of 'array' array */</span></span><br><span class="line">  TValue *<span class="built_in">array</span>;  <span class="comment">/* array part */</span></span><br><span class="line">  Node *node;</span><br><span class="line">  Node *lastfree;  <span class="comment">/* any free position is before this position */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> *<span class="title">metatable</span>;</span></span><br><span class="line">  GCObject *gclist;</span><br><span class="line">&#125; Table;</span><br></pre></td></tr></table></figure><ul><li>TKey：哈希表里每个节点的key值，除了包含作为key的值，还指向同哈希值的下一个节点。</li><li>Node：哈希表的内的每个节点，包含key和value。</li><li><p>Table：表结构     </p><ul><li>lsizenode：哈希表大小的log2(哈希表大小为2的幂次)。 </li><li>sizearray：数组大小(数组大小为2的幂次)。</li><li>array：数组头部指针。</li><li>node：哈希表头部指针。</li><li>lastfree：指向哈希表内最后一个空着的节点。</li><li>metatable：元表。</li><li>gclist：用于垃圾回收。</li></ul><p>&#8195;&#8195;结构本身很简单明晰，唯一需要多说下的是哈希表的结构，这里推荐篇<a href="https://blog.csdn.net/fwb330198372/article/details/88579361" target="_blank" rel="noopener">文章</a>。<br>&#8195;&#8195;简单来说，这是个闭散列表，TKey里指向的下一个节点就是哈希表内的节点，当新元素(new)的哈希值所指向的位置如果被占据，则检查该位置的老元素(old)是否应该在这：</p></li><li>如果old应在此处，则new找空位，并和old的next连接。</li><li>如果old不应该在此处，则old另找新位置，new占据此处。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="新增元素"><a href="#新增元素" class="headerlink" title="新增元素"></a>新增元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** inserts a new key into a hash table; first, check whether key's main</span></span><br><span class="line"><span class="comment">** position is free. If not, check whether colliding node is in its main</span></span><br><span class="line"><span class="comment">** position or not: if it is not, move colliding node to an empty place and</span></span><br><span class="line"><span class="comment">** put new key in its main position; otherwise (colliding node is in its main</span></span><br><span class="line"><span class="comment">** position), new key goes to an empty position.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">TValue *<span class="title">luaH_newkey</span> <span class="params">(lua_State *L, Table *t, <span class="keyword">const</span> TValue *key)</span> </span>&#123;</span><br><span class="line">  Node *mp;</span><br><span class="line">  TValue aux;</span><br><span class="line">  <span class="keyword">if</span> (ttisnil(key)) luaG_runerror(L, <span class="string">"table index is nil"</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (ttisfloat(key)) &#123;</span><br><span class="line">    lua_Integer k;</span><br><span class="line">    <span class="keyword">if</span> (luaV_tointeger(key, &amp;k, <span class="number">0</span>)) &#123;  <span class="comment">/* does index fit in an integer? */</span></span><br><span class="line">      setivalue(&amp;aux, k);</span><br><span class="line">      key = &amp;aux;  <span class="comment">/* insert it as an integer */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (luai_numisnan(fltvalue(key)))</span><br><span class="line">      luaG_runerror(L, <span class="string">"table index is NaN"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  mp = mainposition(t, key);</span><br><span class="line">  <span class="keyword">if</span> (!ttisnil(gval(mp)) || isdummy(t)) &#123;  <span class="comment">/* main position is taken? */</span></span><br><span class="line">    Node *othern;</span><br><span class="line">    Node *f = getfreepos(t);  <span class="comment">/* get a free place */</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;  <span class="comment">/* cannot find a free place? */</span></span><br><span class="line">      rehash(L, t, key);  <span class="comment">/* grow table */</span></span><br><span class="line">      <span class="comment">/* whatever called 'newkey' takes care of TM cache */</span></span><br><span class="line">      <span class="keyword">return</span> luaH_set(L, t, key);  <span class="comment">/* insert key into grown table */</span></span><br><span class="line">    &#125;</span><br><span class="line">    lua_assert(!isdummy(t));</span><br><span class="line">    othern = mainposition(t, gkey(mp));</span><br><span class="line">    <span class="keyword">if</span> (othern != mp) &#123;  <span class="comment">/* is colliding node out of its main position? */</span></span><br><span class="line">      <span class="comment">/* yes; move colliding node into free position */</span></span><br><span class="line">      <span class="keyword">while</span> (othern + gnext(othern) != mp)  <span class="comment">/* find previous */</span></span><br><span class="line">        othern += gnext(othern);</span><br><span class="line">      gnext(othern) = cast_int(f - othern);  <span class="comment">/* rechain to point to 'f' */</span></span><br><span class="line">      *f = *mp;  <span class="comment">/* copy colliding node into free pos. (mp-&gt;next also goes) */</span></span><br><span class="line">      <span class="keyword">if</span> (gnext(mp) != <span class="number">0</span>) &#123;</span><br><span class="line">        gnext(f) += cast_int(mp - f);  <span class="comment">/* correct 'next' */</span></span><br><span class="line">        gnext(mp) = <span class="number">0</span>;  <span class="comment">/* now 'mp' is free */</span></span><br><span class="line">      &#125;</span><br><span class="line">      setnilvalue(gval(mp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">/* colliding node is in its own main position */</span></span><br><span class="line">      <span class="comment">/* new node will go into free position */</span></span><br><span class="line">      <span class="keyword">if</span> (gnext(mp) != <span class="number">0</span>)</span><br><span class="line">        gnext(f) = cast_int((mp + gnext(mp)) - f);  <span class="comment">/* chain new position */</span></span><br><span class="line">      <span class="keyword">else</span> lua_assert(gnext(f) == <span class="number">0</span>);</span><br><span class="line">      gnext(mp) = cast_int(f - mp);</span><br><span class="line">      mp = f;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  setnodekey(L, &amp;mp-&gt;i_key, key);</span><br><span class="line">  luaC_barrierback(L, t, key);</span><br><span class="line">  lua_assert(ttisnil(gval(mp)));</span><br><span class="line">  <span class="keyword">return</span> gval(mp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;代码注释本身就说的挺清楚了。在这里，mainposition是用于获取正确的哈希值，getfreepos是获取当前空余位置，rehash则是在没有空余位置时进行扩容。</p><h3 id="Rehash"><a href="#Rehash" class="headerlink" title="Rehash"></a>Rehash</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** nums[i] = number of keys 'k' where 2^(i - 1) &lt; k &lt;= 2^i</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rehash</span> <span class="params">(lua_State *L, Table *t, <span class="keyword">const</span> TValue *ek)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> asize;  <span class="comment">/* optimal size for array part */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> na;  <span class="comment">/* number of keys in the array part */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> nums[MAXABITS + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> totaluse;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= MAXABITS; i++) nums[i] = <span class="number">0</span>;  <span class="comment">/* reset counts */</span></span><br><span class="line">  na = numusearray(t, nums);  <span class="comment">/* count keys in array part */</span></span><br><span class="line">  totaluse = na;  <span class="comment">/* all those keys are integer keys */</span></span><br><span class="line">  totaluse += numusehash(t, nums, &amp;na);  <span class="comment">/* count keys in hash part */</span></span><br><span class="line">  <span class="comment">/* count extra key */</span></span><br><span class="line">  na += countint(ek, nums);</span><br><span class="line">  totaluse++;</span><br><span class="line">  <span class="comment">/* compute new size for array part */</span></span><br><span class="line">  asize = computesizes(nums, &amp;na);</span><br><span class="line">  <span class="comment">/* resize the table to new computed sizes */</span></span><br><span class="line">  luaH_resize(L, t, asize, totaluse - na);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;rehash的主要工作时统计当前table种到底有多少有效键值对，以及决定数组部分需要开辟多少空间，其原则时最终数组部分的利用率需要超过50%。<br>&#8195;&#8195;这里用到了数组nums来帮助统计，统计的是在$\displaystyle 2^{i-1}$与$\displaystyle 2^{i}$的key的数量。<br>&#8195;&#8195;numusearray用于统计数组部分的键值。<br>&#8195;&#8195;numusehash用于统计哈希表部分的键值，需要注意的是，这里会把na(数组部分键值数)也传进去，对于可以加入数组部分的键，则会加到更新nums并累加na。<br>&#8195;&#8195;computesizes计算在不低于50%利用率下，数组所应该维持的空间大小。<br>&#8195;&#8195;luaH_resize则是根据统计数据，将不能放入数组的键值塞入哈希表。</p><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** main search function</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> TValue *<span class="title">luaH_get</span> <span class="params">(Table *t, <span class="keyword">const</span> TValue *key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (ttype(key)) &#123;</span><br><span class="line">    <span class="keyword">case</span> LUA_TSHRSTR: <span class="keyword">return</span> luaH_getshortstr(t, tsvalue(key));</span><br><span class="line">    <span class="keyword">case</span> LUA_TNUMINT: <span class="keyword">return</span> luaH_getint(t, ivalue(key));</span><br><span class="line">    <span class="keyword">case</span> LUA_TNIL: <span class="keyword">return</span> luaO_nilobject;</span><br><span class="line">    <span class="keyword">case</span> LUA_TNUMFLT: &#123;</span><br><span class="line">      lua_Integer k;</span><br><span class="line">      <span class="keyword">if</span> (luaV_tointeger(key, &amp;k, <span class="number">0</span>)) <span class="comment">/* index is int? */</span></span><br><span class="line">        <span class="keyword">return</span> luaH_getint(t, k);  <span class="comment">/* use specialized version */</span></span><br><span class="line">      <span class="comment">/* else... */</span></span><br><span class="line">    &#125;  <span class="comment">/* FALLTHROUGH */</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> getgeneric(t, key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;当查询键为整数键并在数组范围内时，则在数组部分查询。否则，根据键在哈希表查询。当存在相同哈希的冲突键值对时，则根据next遍历链表查询。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>查找：</p><ul><li>如果输入的key是正整数，并且它的值&gt;0&amp;&amp;&lt;=数组大小，则尝试在数组部分查找</li><li>否则则尝试在散列表部分查找：计算出key的散列值，根据此散列值访问Node数组得到散列桶的位置，遍历旗下所有链表元素</li></ul></li><li><p>新增元素：</p><ul><li>哈希表：<ul><li>lastfree找空位置，lastfree与表头重合表示表满了，进行rehash</li><li>新元素(new)的哈希值所指向的位置如果被占据，则检查该位置的老元素(old)是否应该在这：<ul><li>如果old应在此处，则new找空位，并和old的next连接</li><li>如果old不应该在此处，则old另找新位置，new占据此处</li></ul></li></ul></li></ul></li><li>rehash：基本原则为最终数组部分的利用率需要超过50%。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>1、Lua源码欣赏——云风<br>2、<a href="https://zhuanlan.zhihu.com/p/87400150" target="_blank" rel="noopener">Lua设计与实现—Table篇</a><br>3、<a href="https://blog.csdn.net/fwb330198372/article/details/88579361" target="_blank" rel="noopener">Lua 源码分析之Table - Hash部分内部原理</a></p>]]></content>
      
      
      <categories>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua源码之字符串</title>
      <link href="/2020/06/25/Lua%E6%BA%90%E7%A0%81%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/06/25/Lua%E6%BA%90%E7%A0%81%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>lua版本：5.3.5</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>&#8195;&#8195;lua的字符串分为短字符串和长字符串：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Variant tags for strings */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TSHRSTR(LUA_TSTRING | (0 &lt;&lt; 4))  <span class="comment">/* short strings */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TLNGSTR(LUA_TSTRING | (1 &lt;&lt; 4))  <span class="comment">/* long strings */</span></span></span><br></pre></td></tr></table></figure><br>&#8195;&#8195;字符串结构体定义代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Common Header for all collectable objects (in macro form, to be</span></span><br><span class="line"><span class="comment">** included in other objects)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CommonHeaderGCObject *next; lu_byte tt; lu_byte marked</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Header for string value; string bytes follow the end of this structure</span></span><br><span class="line"><span class="comment">** (aligned according to 'UTString'; see next).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TString</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  lu_byte extra;  <span class="comment">/* reserved words for short strings; "has hash" for longs */</span></span><br><span class="line">  lu_byte shrlen;  <span class="comment">/* length for short strings */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> hash;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">size_t</span> lnglen;  <span class="comment">/* length for long strings */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TString</span> *<span class="title">hnext</span>;</span>  <span class="comment">/* linked list for hash table */</span></span><br><span class="line">  &#125; u;</span><br><span class="line">&#125; TString;</span><br></pre></td></tr></table></figure></p><ul><li>CommonHeader：用于GC。</li><li>TString ：字符串的结构体。<ul><li>extra：对于短字符串，extra表示是否为保留字(即：and、or这些关键字，不参与回收)；对于长字符串，extra可以表示该字符串是否进行过hash。</li><li>shrlen：短字符串的长度。</li><li>hash：短字符串在创建时就会计算哈希值，并根据此哈希值将短字符串放入stringtable这一个开散列表中；长字符串则是独立存放，并且哈希值不会立即计算，而是等到需要的时候再计算。</li><li>union {lnglen, hnext}：联合体。当是短字符串时，用到的hnext，表示与其相同哈希值的下一个TString的指针；当时长字符串时，用到的是lnglen，表示长字符串的长度。</li></ul></li></ul><p>&#8195;&#8195;用于存放短字符串的全局哈希表，会动态更新大小：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stringtable</span> &#123;</span></span><br><span class="line">  TString **hash;</span><br><span class="line">  <span class="keyword">int</span> nuse;  <span class="comment">/* number of elements */</span></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">&#125; stringtable;</span><br></pre></td></tr></table></figure></p><ul><li>hash：存储短字符串的散列表。</li><li>nuse：当前实际元素数。</li><li>size：散列数组的长度。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>&#8195;&#8195;短字符串只会保存一份，所以要比较短字符串直接比较地址就可以了。<br>&#8195;&#8195;长字符串比较函数则为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** equality for long strings</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">luaS_eqlngstr</span> <span class="params">(TString *a, TString *b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> len = a-&gt;u.lnglen;</span><br><span class="line">  lua_assert(a-&gt;tt == LUA_TLNGSTR &amp;&amp; b-&gt;tt == LUA_TLNGSTR);</span><br><span class="line">  <span class="keyword">return</span> (a == b) ||  <span class="comment">/* same instance or... */</span></span><br><span class="line">    ((len == b-&gt;u.lnglen) &amp;&amp;  <span class="comment">/* equal length and ... */</span></span><br><span class="line">     (<span class="built_in">memcmp</span>(getstr(a), getstr(b), len) == <span class="number">0</span>));  <span class="comment">/* equal contents */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;比较方式则是先判断是否地址相同，地址相同则字符串肯定相同。接下来则是比较字符串长度，长度不同则字符串必然不同，最后则是逐字比较内容。</p><h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">luaS_hash</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">size_t</span> l, <span class="keyword">unsigned</span> <span class="keyword">int</span> seed)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> h = seed ^ cast(<span class="keyword">unsigned</span> <span class="keyword">int</span>, l);</span><br><span class="line">  <span class="keyword">size_t</span> <span class="built_in">step</span> = (l &gt;&gt; LUAI_HASHLIMIT) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; l &gt;= <span class="built_in">step</span>; l -= <span class="built_in">step</span>)</span><br><span class="line">    h ^= ((h&lt;&lt;<span class="number">5</span>) + (h&gt;&gt;<span class="number">2</span>) + cast_byte(str[l - <span class="number">1</span>]));</span><br><span class="line">  <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;字符串哈希时会用到一个随机种子，以降低被人采用Hash Dos攻击的可能。并且采用了step步长来加速哈希长字符串的过程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">luaS_hashlongstr</span> <span class="params">(TString *ts)</span> </span>&#123;</span><br><span class="line">  lua_assert(ts-&gt;tt == LUA_TLNGSTR);</span><br><span class="line">  <span class="keyword">if</span> (ts-&gt;extra == <span class="number">0</span>) &#123;  <span class="comment">/* no hash? */</span></span><br><span class="line">    ts-&gt;hash = luaS_hash(getstr(ts), ts-&gt;u.lnglen, ts-&gt;hash);</span><br><span class="line">    ts-&gt;extra = <span class="number">1</span>;  <span class="comment">/* now it has its hash */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ts-&gt;hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;长字符串初始不会进行哈希，如果需要哈希则得手动调用此函数(目前长字符串只有在作为表key值时才会进行哈希)。这里会通过extra字段表示是否哈希过。另外，长字符串初始化时，hash字段直接被赋值为全局种子的值，所以这里传了hash作为参数。</p><h3 id="短字符串内部化"><a href="#短字符串内部化" class="headerlink" title="短字符串内部化"></a>短字符串内部化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** checks whether short string exists and reuses it or creates a new one</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> TString *<span class="title">internshrstr</span> <span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">size_t</span> l)</span> </span>&#123;</span><br><span class="line">  TString *ts;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> h = luaS_hash(str, l, g-&gt;seed);</span><br><span class="line">  TString **<span class="built_in">list</span> = &amp;g-&gt;strt.hash[lmod(h, g-&gt;strt.<span class="built_in">size</span>)];</span><br><span class="line">  lua_assert(str != <span class="literal">NULL</span>);  <span class="comment">/* otherwise 'memcmp'/'memcpy' are undefined */</span></span><br><span class="line">  <span class="keyword">for</span> (ts = *<span class="built_in">list</span>; ts != <span class="literal">NULL</span>; ts = ts-&gt;u.hnext) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l == ts-&gt;shrlen &amp;&amp;</span><br><span class="line">        (<span class="built_in">memcmp</span>(str, getstr(ts), l * <span class="keyword">sizeof</span>(<span class="keyword">char</span>)) == <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="comment">/* found! */</span></span><br><span class="line">      <span class="keyword">if</span> (isdead(g, ts))  <span class="comment">/* dead (but not collected yet)? */</span></span><br><span class="line">        changewhite(ts);  <span class="comment">/* resurrect it */</span></span><br><span class="line">      <span class="keyword">return</span> ts;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (g-&gt;strt.nuse &gt;= g-&gt;strt.<span class="built_in">size</span> &amp;&amp; g-&gt;strt.<span class="built_in">size</span> &lt;= MAX_INT/<span class="number">2</span>) &#123;</span><br><span class="line">    luaS_resize(L, g-&gt;strt.<span class="built_in">size</span> * <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">list</span> = &amp;g-&gt;strt.hash[lmod(h, g-&gt;strt.<span class="built_in">size</span>)];  <span class="comment">/* recompute with new size */</span></span><br><span class="line">  &#125;</span><br><span class="line">  ts = createstrobj(L, l, LUA_TSHRSTR, h);</span><br><span class="line">  <span class="built_in">memcpy</span>(getstr(ts), str, l * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">  ts-&gt;shrlen = cast_byte(l);</span><br><span class="line">  ts-&gt;u.hnext = *<span class="built_in">list</span>;</span><br><span class="line">  *<span class="built_in">list</span> = ts;</span><br><span class="line">  g-&gt;strt.nuse++;</span><br><span class="line">  <span class="keyword">return</span> ts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;用于创建和获取短字符串的函数，其过程为：</p><ol><li>调用luaS_hash，计算哈希值。</li><li>在stringtable里找是否有相同的字符串，有则直接返回该字符串。没有则继续。</li><li>检查stringtable的大小，如果元素数大于数组长度，并且数组长度小于最大值的一半的话，则进行resize，将哈希表扩大为两倍。</li><li>创建短字符串结构体并初始化，将其加入散列表。</li><li>更新散列表的元素数记录。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** If possible, shrink string table</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkSizes</span> <span class="params">(lua_State *L, global_State *g)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (g-&gt;gckind != KGC_EMERGENCY) &#123;</span><br><span class="line">    l_mem olddebt = g-&gt;GCdebt;</span><br><span class="line">    <span class="keyword">if</span> (g-&gt;strt.nuse &lt; g-&gt;strt.<span class="built_in">size</span> / <span class="number">4</span>)  <span class="comment">/* string table too big? */</span></span><br><span class="line">      luaS_resize(L, g-&gt;strt.<span class="built_in">size</span> / <span class="number">2</span>);  <span class="comment">/* shrink it a little */</span></span><br><span class="line">    g-&gt;GCestimate += g-&gt;GCdebt - olddebt;  <span class="comment">/* update estimate */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;在gc时，如果元素数量小于哈希表数组大小的四分之一，则会将哈希表缩小一半。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>短字符串：<ul><li>存于哈希表stringtable中这一开散列表中，相同字符串只会存一份。</li><li>创建时就会计算哈希值。</li><li>哈希表stringtable会动态调整表大小。</li></ul></li><li>长字符串：<ul><li>可能保存多份相同的长字符串。</li><li>创建时不会计算哈希值，只有用到的时候才会计算。</li></ul></li><li>其他：<ul><li>计算哈希值时会利用随机种子来减少被Hash Dos攻击的可能性。</li><li>计算哈希值时会采用步长来加快计算过程。</li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>1、Lua源码欣赏——云风<br>2、<a href="https://zhuanlan.zhihu.com/p/61441722" target="_blank" rel="noopener">Lua设计与实现—字符串篇</a></p>]]></content>
      
      
      <categories>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【从零开始的SoftRenderer】3.渲染管线</title>
      <link href="/2020/06/21/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84SoftRenderer-3-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"/>
      <url>/2020/06/21/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84SoftRenderer-3-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<p>&#8195;&#8195;GPU在接受了CPU的指令和数据后，所做的一系列流水线作业，被称作渲染管线。</p><h2 id="GPU渲染管线"><a href="#GPU渲染管线" class="headerlink" title="GPU渲染管线"></a>GPU渲染管线</h2><p><img src="https://img-blog.csdnimg.cn/20200621142528724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5azIyMzM0NA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>&#8195;&#8195;上图就是GPU渲染管线的图示。图中绿色表示完全可编程，黄色表示可配置，蓝色表示完全固定。下面介绍下一些主要的渲染阶段：</p><ul><li><strong>顶点着色器：</strong> 完全可编程，主要做的是我们在本系列第二章中所讲的坐标变换的过程，所以将输入的顶点乘以MVP矩阵输出，就是一个最简单的顶点着色器。除此之外，这一阶段还可以对一些顶点的属性(法线、纹理等等)进行处理，交给后面的阶段去用。</li><li><strong>裁剪：</strong> 在NDC空间进行裁剪，被截取的三角形会在边界处生成新的顶点。</li><li><strong>屏幕映射：</strong> 将顶点坐标映射到屏幕上，即进行视口变换。</li><li><strong>三角形设置：</strong> 之前所处理的都是顶点，这里则会计算三角形的网格表示数据，以为后面的阶段做准备。</li><li><strong>三角形遍历：</strong> 这里则是本系列第一章讲的内容，即遍历三角形可能覆盖的像素，根据重心坐标确定像素是否在三角形内部，然后则将顶点的各种属性进行插值得到该像素(片元)的属性，交给后面的片元着色器去处理。</li><li><strong>片元着色器：</strong> 根据对三角形各顶点插值得到的属性，决定此片元需要绘制什么颜色。一般各种着色计算都是在此处。</li><li><strong>逐片元操作：</strong> 根据配置对片元进行一各种操作，如：深度测试、模板测试、混合等等。</li></ul><p>&#8195;&#8195;除此之外，还有可选的<strong>曲面细分着色器</strong>和<strong>几何着色器</strong>。<strong>曲面细分着色器</strong>可以将三角形分割成更小的三角形，以提升模型的精度。<strong>几何着色器</strong>则可在多边形网格处理并增删顶点。不过这两个我目前都还没有实践过，理解不够，以后再细讲吧。</p>]]></content>
      
      
      <categories>
          
          <category> 从零开始的SoftRenderer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【从零开始的SoftRenderer】2.坐标变换</title>
      <link href="/2020/06/21/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84SoftRenderer-2-%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/"/>
      <url>/2020/06/21/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84SoftRenderer-2-%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>&#8195;&#8195;一个物体要投影到屏幕上需要依次经过 Model(世界矩阵，转换到世界空间)、View(视图矩阵，转换到观察空间/摄像机空间)、Projection(投影矩阵，转换到裁剪空间)，合起来就是常见的MVP矩阵。<br>&#8195;&#8195;Model矩阵和View矩阵很好理解，只是单纯的坐标系变换(注：Unity里摄像机坐标系采用的是右手系，与其世界坐标系相反，算是一个小的坑点)，如果有不理解的推荐一个视频课程，<a href="https://space.bilibili.com/88461692#!/channel/detail?cid=9450" target="_blank" rel="noopener">线性代数的本质</a>，这里就不详细说明了。</p><h2 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h2><p>&#8195;&#8195;在介绍投影矩阵前，我们先来了解下齐次坐标。齐次坐标就是将一个原本是n维的向量用一个n+1维向量来表示，比如三维向量$\displaystyle (x,y,z)$采用$\displaystyle (x,y,z,w)$来表示。其存在的意义有篇文章介绍的很好，这里给出<a href="http://www.songho.ca/math/homogeneous/homogeneous.html" target="_blank" rel="noopener">原文</a>和<a href="https://blog.csdn.net/janestar/article/details/44244849" target="_blank" rel="noopener">译文</a>链接。而在线性变换过程中，齐次坐标的作用主要是提供了位移功能。</p><script type="math/tex; mode=display">\begin{bmatrix}  \color{red}1 & \color{red}0 & \color{red}0 & \color{red}{T_x} \\ \color{green}0 & \color{green}1 & \color{green}0 & \color{green}{T_y} \\ \color{blue}0 & \color{blue}0 & \color{blue}1 & \color{blue}{T_z} \\ \color{purple}0 & \color{purple}0 & \color{purple}0 & \color{purple}1 \end{bmatrix} \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix} = \begin{pmatrix} x + \color{red}{T_x} \\ y + \color{green}{T_y} \\ z + \color{blue}{T_z} \\ 1 \end{pmatrix}</script><p>&#8195;&#8195;上面就是一个标准的位移变换，移动的距离为$\displaystyle (\color{red}{T_x},\color{green}{T_y},\color{blue}{T_z})$，而齐次坐标$\displaystyle w$则为1(当$\displaystyle w$为0时，则说明$\displaystyle (x,y,z)$代表一个不可位移的向量)。</p><h2 id="投影矩阵"><a href="#投影矩阵" class="headerlink" title="投影矩阵"></a>投影矩阵</h2><p>&#8195;&#8195;这里先推荐一篇很好的<a href="http://www.songho.ca/opengl/gl_projectionmatrix.html" target="_blank" rel="noopener">投影文章</a>。<br>&#8195;&#8195;投影有两种方式，一种是近大远小的透视投影，另一种则是远近一样大的正交投影。我们的摄像机会有一个可视范围，投影要做的其实就是将这个可视范围转换成标准设备坐标(NDC)$\displaystyle ( -1\leqslant x\leqslant 1,-1\leqslant y\leqslant 1,-1\leqslant z\leqslant 1)$，超出此范围的顶点则会进行裁剪。</p><h3 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h3><p><img src="https://img-blog.csdnimg.cn/20200618231329484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5azIyMzM0NA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>&#8195;&#8195;如上图所示，左边是我们摄像机的可视范围，右边则是NDC范围。透视投影的可视范围是一个锥形区域，现在我们需要想办法将其转换成一个正方体范围。这里的$\displaystyle n, f$表示近平面和远平面距摄像机的距离，$\displaystyle l、r、t、b$则为近平面的左、右、上、下。<br><img src="https://img-blog.csdnimg.cn/20200619213827856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5azIyMzM0NA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">&#8195;&#8195;我们先考虑如何求投影坐标的$\displaystyle x$。其实观察空间的原点和目标点相连的直线与近平面相较的坐标点，就是投影的坐标点，而这一点我们可以很容易的通过相似三角形等比计算出来。所以可得$\displaystyle x_p = \frac{n\cdot x_e}{-z_e}$(注：这里$\displaystyle x_e$表示该点在观察空间上的$\displaystyle x$坐标)。同理，$\displaystyle y_p = \frac{n\cdot y_e}{-z_e}$。我们可以先观察下这个坐标，$\displaystyle {z_e}$在分母上，这是一般的矩阵变换不可能得到的结果，我们需要借助齐次坐标来实现，所以我们首先可以确定的是，经透视投影矩阵变换后的坐标的$\displaystyle w$，一定是$\displaystyle {z_e}$的倍数。于是透视投影矩阵的第四行可以确定了。</p><script type="math/tex; mode=display">\left(\begin{matrix}x_c\\y_c\\z_c\\w_c\end{matrix}\right)=\left(\begin{matrix}\cdot & \cdot &\cdot &\cdot\\\cdot & \cdot &\cdot &\cdot\\\cdot & \cdot &\cdot &\cdot\\0 & 0 & -1 & 0\end{matrix}\right) \left(\begin{matrix}x_e\\y_e\\z_e\\w_e\end{matrix}\right),\therefore w_c=-z_e</script><p>&#8195;&#8195;接下来我们来确定$\displaystyle x$和$\displaystyle y$坐标该如何变换。以$\displaystyle x$为例，投影到近平面的点$\displaystyle x_p$的范围是$\displaystyle [l,r]$，我们的目标是将其转换为NDC下的坐标点$\displaystyle x_n$(注：这里的$\displaystyle x_n$是齐次坐标进行了转换后的结果，即$\displaystyle x_n=\frac{x_c}{w_c}=\frac{x_c}{-z_e}$)，而$\displaystyle l$与$\displaystyle r$是对称的，即 $\displaystyle l+r = 0$。所以我们可推得公式：</p><script type="math/tex; mode=display">x_n=\frac{x_p}{r}=\frac{nx_e}{-z_er}</script><p>&#8195;&#8195;同理可得：</p><script type="math/tex; mode=display">y_n=\frac{y_p}{t}=\frac{ny_e}{-z_et}</script><p>&#8195;&#8195;所以矩阵的前两行我们又可以确定了</p><script type="math/tex; mode=display">\left(\begin{matrix}x_c\\y_c\\z_c\\w_c\end{matrix}\right)=\left(\begin{matrix}\frac{n}{r} & 0 & 0 & 0\\0 & \frac{n}{t} & 0 & 0\\\cdot & \cdot & \cdot & \cdot\\0 & 0 & -1 & 0\end{matrix}\right) \left(\begin{matrix}x_e\\y_e\\z_e\\w_e\end{matrix}\right)</script><p>&#8195;&#8195;最后我们来确定$\displaystyle z$轴的变换。在观察空间中$\displaystyle z_e$的范围是$\displaystyle [-n,-f]$，我们希望也能将其转换成NDC空间的$\displaystyle [-1,1]$。因为这个不可能和$\displaystyle x,y$有关，所以我们设矩阵为</p><script type="math/tex; mode=display">\left(\begin{matrix}x_c\\y_c\\z_c\\w_c\end{matrix}\right)=\left(\begin{matrix}\frac{n}{r} & 0 & 0 & 0\\0 & \frac{n}{t} & 0 & 0\\0 & 0 & A & B\\0 & 0 & -1 & 0\end{matrix}\right) \left(\begin{matrix}x_e\\y_e\\z_e\\w_e\end{matrix}\right)</script><p>&#8195;&#8195;可推得</p><script type="math/tex; mode=display">z_n =\frac{z_c}{w_c}= \frac{Az_e + Bw_e}{-z_e}= \frac{Az_e + B}{-z_e}</script><p>&#8195;&#8195;我们可以分别将$\displaystyle (-1,1)$代入$\displaystyle z_n$，$\displaystyle (-n,-f)$代入$\displaystyle z_e$得到方程组</p><script type="math/tex; mode=display">\left\{\begin{array}{lr}-An + B = -n &\\-Af + B = f & \end{array}\right.</script><p>&#8195;&#8195;解该方程组得到</p><script type="math/tex; mode=display">\left\{\begin{array}{lr}A =  -\frac{f+n}{f-n}&\\B = -\frac{2fn}{f-n}& \end{array}\right.</script><p>&#8195;&#8195;所以最终可推得透视投影矩阵</p><script type="math/tex; mode=display">\left(\begin{matrix}x_c\\y_c\\z_c\\w_c\end{matrix}\right)=\left(\begin{matrix}\frac{n}{r} & 0 & 0 & 0\\0 & \frac{n}{t} & 0 & 0\\0 & 0 &  -\frac{f+n}{f-n} & -\frac{2fn}{f-n}\\0 & 0 & -1 & 0\end{matrix}\right) \left(\begin{matrix}x_e\\y_e\\z_e\\w_e\end{matrix}\right)</script><h3 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h3><p><img src="https://img-blog.csdnimg.cn/20200620220926399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5azIyMzM0NA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>&#8195;&#8195;相较于透视投影，正交投影就简单太多了，其转换过程与一般的坐标系变换并没有太大分别，这里就不展开谈了，直接上矩阵：</p><script type="math/tex; mode=display">\left(\begin{matrix}\frac{1}{r} & 0 & 0 & 0\\0 & \frac{1}{t} & 0 & 0\\0 & 0 & \frac{-2}{f-n} & -\frac{f+n}{f-n}\\0 & 0 & 0 & 1\end{matrix}\right)</script><h2 id="视口矩阵"><a href="#视口矩阵" class="headerlink" title="视口矩阵"></a>视口矩阵</h2><p>&#8195;&#8195;视口矩阵既是将NDC下的坐标转换为屏幕上的指定像素区域，也可以理解为该摄像机在屏幕上的显示区域。我这里就偷懒直接覆盖全屏幕了。</p><script type="math/tex; mode=display">\left(\begin{matrix}\frac{width}{2} & 0 & 0 & \frac{width}{2}\\0 & \frac{height}{2} & 0 & \frac{height}{2}\\0 & 0 & 1 & 0\\0 & 0 & 0 & 1\end{matrix}\right)</script><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&#8195;&#8195;这一章中，我们介绍了三维空间中的坐标是如何一步步转换为屏幕上坐标的，其实这里结合上一章中的绘制三角形，我们就已经可以尝试去渲染3d模型了。所以，下一章则会介绍下最基本的渲染管线。</p>]]></content>
      
      
      <categories>
          
          <category> 从零开始的SoftRenderer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【从零开始的SoftRenderer】1.绘制三角形</title>
      <link href="/2020/06/21/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84SoftRenderer-1-%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2/"/>
      <url>/2020/06/21/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84SoftRenderer-1-%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<p>&#8195;&#8195;我们最终是要将三维的物体绘制到平面上，那么首先我们需要明白的是如何在屏幕上绘制二维的物体。而在二维的多边形中，三角形无疑是最特别的一种，它具有以下特性：</p><ol><li>是边数最少多边形</li><li>所有多边形可以都可拆解成三角形</li><li>即使在三维空间中，三角形的所有顶点也必然在同一平面上</li></ol><p>&#8195;&#8195;所以我们的软件渲染器的第一步，就是要在屏幕上绘制出一个三角形。绘制三角形的方式多种多样，而光栅化主要采用的是一种叫做重心坐标的方法。</p><h2 id="重心坐标"><a href="#重心坐标" class="headerlink" title="重心坐标"></a>重心坐标</h2><p><img src="https://img-blog.csdnimg.cn/20200617000441399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5azIyMzM0NA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>&#8195;&#8195;如上图所示，重心坐标的定义为，对于平面内任意一点P，都可以用三角形的三个顶点表示，即 $\displaystyle P = αA + βB + γC$，并且还满足$\displaystyle α + β + γ = 1$。而如果P点在三角形内，那么还会满足$\displaystyle ( 0\leqslant α\leqslant 1, 0\leqslant β\leqslant 1, 0\leqslant γ\leqslant 1)$。可以类比求两点间一点公式来更好的理解：$\displaystyle P = αA + ( 1 - α) B$。<br>&#8195;&#8195;光栅化的过程其实就是求屏幕上每个像素的颜色的过程，所以我们可以遍历三角形可能覆盖的所有点作为点P，求出其重心坐标$\displaystyle( α , β , γ )$，然后P点的任意属性(颜色，uv，深度等等)我们都可以通过三角形的三个顶点根据重心坐标插值求得了。下面我们来推导下重心坐标该怎么求。</p><h2 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h2><p><img src="https://img-blog.csdnimg.cn/2020061708180713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5azIyMzM0NA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>&#8195;&#8195;根据重心坐标的定义，我们可以把公式改写为</p><script type="math/tex; mode=display">P\ =\ ( 1\ -\ β\ -\ γ) A\ +\ βB\ +\ γC</script><p>&#8195;&#8195;我们还可以进一步将其转换为关于三个向量的公式</p><script type="math/tex; mode=display">\overrightarrow{PA} \ +\ β\overrightarrow{AB} \ +\ γ\overrightarrow{AC} \ =\ \vec{0}</script><p>&#8195;&#8195;这个公式还可以进一步拆成两个公式，分别计算x，y</p><script type="math/tex; mode=display">\overrightarrow{PA}_{x} +\ β\overrightarrow{AB}_{x} +\ γ\overrightarrow{AC}_{x} \ =\ 0</script><script type="math/tex; mode=display">\overrightarrow{PA}_{y} +\ β\overrightarrow{AB}_{y} +\ γ\overrightarrow{AC}_{y} \ =\ 0</script><p>&#8195;&#8195;这两个公式可以再转为矩阵形式表示</p><script type="math/tex; mode=display">\begin{bmatrix}β & γ & 1\end{bmatrix}\begin{bmatrix}\overrightarrow{AB}_{x}\\\overrightarrow{AC}_{x}\\\overrightarrow{PA}_{x}\end{bmatrix} \ =0</script><script type="math/tex; mode=display">\begin{bmatrix}β & γ & 1\end{bmatrix}\begin{bmatrix}\overrightarrow{AB}_{y}\\\overrightarrow{AC}_{y}\\\overrightarrow{PA}_{y}\end{bmatrix} \ =0</script><p>&#8195;&#8195;从上面的公式可以看出，向量$\displaystyle ( β, γ, 1)$分别与向量$\displaystyle (\overrightarrow{AB}{_x} , \overrightarrow{AC}{_x} , \overrightarrow{PA}{_x})$和向量$\displaystyle (\overrightarrow{AB}{_y} , \overrightarrow{AC}{_y} , \overrightarrow{PA}{_y})$垂直，即是这两个向量的叉乘。假定$\displaystyle (\overrightarrow{AB}{_x} , \overrightarrow{AC}{_x} , \overrightarrow{PA}{_x})$和向量$\displaystyle (\overrightarrow{AB}{_y} , \overrightarrow{AC}{_y} , \overrightarrow{PA}{_y})$的叉乘为向量$\displaystyle u$，那么$\displaystyle β = u.x / u.z$，$\displaystyle γ = u.y / u.z$。如果$\displaystyle u.z$为0，则说明该三角形其实已经退化成了线段。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector3 <span class="title">DrawUtil::CalcuBarycentric</span><span class="params">(Vector2 *pts, Vector2 point)</span> </span>&#123;</span><br><span class="line">    Vector3 temp[<span class="number">2</span>];</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        temp[i][<span class="number">0</span>] = pts[<span class="number">1</span>][i] - pts[<span class="number">0</span>][i];</span><br><span class="line">        temp[i][<span class="number">1</span>] = pts[<span class="number">2</span>][i] - pts[<span class="number">0</span>][i];</span><br><span class="line">        temp[i][<span class="number">2</span>] = pts[<span class="number">0</span>][i] - point[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Vector3 u = temp[<span class="number">0</span>].cross(temp[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(u.z) &gt; <span class="number">1e-2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Vector3(<span class="number">1.0f</span> - (u.x + u.y) / u.z, u.x / u.z, u.y / u.z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Vector3(<span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&#8195;&#8195;在绘制三角形这一章中，我们着重介绍了重心坐标的定义和推导，有了重心坐标，我们就可以通过三角形三个顶点的各种属性，插值得到三角形内任一点的各种属性。这对于光栅化渲染器是有着相当广泛的应用的，举个例子：<br>&#8195;&#8195; <strong>Z-Buffer</strong>，即深度缓存，当三角形投影到了屏幕上后，它的z值我们并不是直接舍弃不用，相反，我们可以用z值来判断三角形距屏幕的距离，离屏幕近的肯定是会覆盖后面的。但是在空间中，两个三角形是完全可能互相穿插的，所以我们真正要比较的是像素所对应的三角形内的那一点的远近关系，而这一点的z值则是通过对三角形三个顶点z值进行插值得到的。Z-buffer则是用来记录某一像素最近深度的，在绘制过程中如果遇到大于缓存中深度的片段，就会直接舍弃。</p>]]></content>
      
      
      <categories>
          
          <category> 从零开始的SoftRenderer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【从零开始的SoftRenderer】0.前言</title>
      <link href="/2020/06/21/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84SoftRenderer-0-%E5%89%8D%E8%A8%80/"/>
      <url>/2020/06/21/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84SoftRenderer-0-%E5%89%8D%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<p>&#8195;&#8195;本人图形学萌新一个，之前有跟着<a href="https://learnopengl-cn.github.io/" target="_blank" rel="noopener">LearnOpenGL</a>进行一点学习，但是总觉得对一些基础的东西并没有真正理解。年前在github上发现一个很不错的工程，<a href="https://github.com/ssloy/tinyrenderer" target="_blank" rel="noopener">tinyrender</a>，便开始跟着上面的介绍开始着手自己写一个软件渲染器，以模拟底层的实现。<br><img src="https://img-blog.csdnimg.cn/20200621125857458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5azIyMzM0NA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>&#8195;&#8195;<a href="https://github.com/wyk223344/SoftRenderer" target="_blank" rel="noopener">代码链接</a>在此。<br>&#8195;&#8195;其实我这个软件渲染器是一个最简版的，光照、阴影、后处理等等都没有，只是完成了通过摄像机把模型渲染到屏幕这一最基本的流程而已。当时我纠结了一阵该如何设计顶点着色器和片段着色器的结构和数据交互后，便直接滚去玩unity了。或许之后遇到什么我觉得难以理解的图形学知识会再在这个SoftRender上实践下吧。<br>&#8195;&#8195;下面我则就这个渲染器水几篇文章，整理归纳一下所学到的知识。</p><ol><li><a href="https://wyk223344.github.io/2020/06/21/从零开始的SoftRenderer-1-绘制三角形/">绘制三角形</a></li><li><a href="https://wyk223344.github.io/2020/06/21/从零开始的SoftRenderer-2-坐标变换/">坐标变换</a></li><li><a href="https://wyk223344.github.io/2020/06/21/从零开始的SoftRenderer-3-渲染管线/">渲染管线</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 从零开始的SoftRenderer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/04/18/hello-world/"/>
      <url>/2020/04/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 闲谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
